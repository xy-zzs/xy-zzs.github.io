import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as a,f as i}from"./app-DmhNJ90i.js";const p={},t=i('<h1 id="架构及规范导航栏" tabindex="-1"><a class="header-anchor" href="#架构及规范导航栏"><span>架构及规范导航栏</span></a></h1><h2 id="什么是restful" tabindex="-1"><a class="header-anchor" href="#什么是restful"><span>什么是Restful</span></a></h2><p>Restful是一种架构设计风格，提供了设计原则和约束条件，而不是架构，而满足这些约束条件和原则的应用程序或设计就是 Restful架构或服务。</p><p>主要的设计原则：</p><ul><li>资源与URI</li><li>统一资源接口(HTTP方法如GET，PUT和POST)</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><p>总之，RESTful的核心就是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作。</p><h2 id="什么是soap" tabindex="-1"><a class="header-anchor" href="#什么是soap"><span>什么是SOAP</span></a></h2><p>简单对象访问协议是一种数据交换协议规范，是一种轻量的、简单的、基于XML的协议的规范。SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的。</p><p>SOAP的消息是基于 xml 并封装成了符合 http 协议，因此，它符合任何路由器、 防火墙或代理服务器的要求。</p><p>SOAP可以使用任何语言来完成，只要发送正确的soap请求即可，基于soap的服务可以在任何平台无需修改即可正常使用。</p><h2 id="rpc" tabindex="-1"><a class="header-anchor" href="#rpc"><span>RPC</span></a></h2><p>RPC 就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p><p>RPC 会隐藏底层的通讯细节（不需要直接处理 Socket 通讯或 HTTP 通讯）</p><p>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于 HTTP 的工作方式）</p><p>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p><p>典型 RPC 远程调用框架</p><ul><li>dubbo，阿里的开源框架。</li><li>RMI实现，利用<code>java.rmi</code>包实现，基于Java远程方法协议( Java Remote Method Protocol )和 Java 的原生序列化。</li><li>SpringCloud框架，微服务全家桶。为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。</li><li>Hessian，是一个轻量级的 remoting onhttp 工具，使用简单的方法提供了 RMI 的功能。 基于HTTP协议，采用二进制编解码。</li><li>thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。</li></ul><p>微服务在本质上，就是 RPC 。RPC 有基于TCP的，HTTP 的的等等。spring cloud是基于spring boot的，spring boot 实现的是 HTTP 协议的 RPC ，算是 RPC 的一个子集。</p><h2 id="什么是soa" tabindex="-1"><a class="header-anchor" href="#什么是soa"><span>什么是SOA</span></a></h2><p>SOA（Service-Oriented Architecture），中文全称：面向服务的架构。</p><p>通俗点来讲，SOA提倡将不同应用程序的业务功能封装成“服务”并宿主起来，通常以接口和契约的形式暴露并提供给外界应用访问（通过交换消息），达到不同系统可重用的目的。</p><p>SOA是一个组件模型，它能将不同的服务通过定义良好的接口和契约联系起来。服务是SOA的基石。</p><h2 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务"><span>微服务</span></a></h2><p>顾名思义，就是很小的服务，所以它属于面向服务架构的一种。通俗一点来说，每个服务都是一个组件，通过编排组合的方式来使用，从而真正做到了独立、解耦、组件化、易维护、可复用、可替换、高可用、最终达到提高交付质量、缩短交付周期的效果；是 SOA 架构演进的结果，更细粒度、更通用化发展，就成了所谓的微服务了。</p><p>SOA 与微服务的区别在于如下几个方面：</p><ul><li>微服务相比于SOA更加精细，微服务更多的以独立的进程的方式存在，互相之间并无影响；</li><li>微服务提供的接口方式更加通用化，例如HTTP RESTful方式，各种终端都可以调用，无关语言、平台限制；</li><li>微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合。</li></ul><p>从专业的角度来看，微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（ RPC 实现）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><p>所以总结起来，微服务是采用轻量级的通信机制互相沟通（RPC）的更细粒度、更通用化发展SOA架构</p><p>微服务 = RPC（实现方式） + SOA（提供思想）</p><h2 id="为什么要使用微服务" tabindex="-1"><a class="header-anchor" href="#为什么要使用微服务"><span>为什么要使用微服务？</span></a></h2><p>技术为业务而生，架构也为业务而出现，当然 SOA 和微服务也是因为业务的发展而出现。出现 SOA 和微服务框架与业务的发展、平台的壮大密不可分，下面借用dubbo的网站架构发展图和说明：</p><figure><img src="http://images.xyzzs.top/image/image-20230206124146652.png_char" alt="image-20230206124146652" tabindex="0" loading="lazy"><figcaption>image-20230206124146652</figcaption></figure><p><mark>单一应用架构</mark></p><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</p><p>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p><p><mark> 垂直应用架构</mark></p><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</p><p>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p><p><mark>分布式服务架构</mark> 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p><p>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p><p><mark>流动计算架构</mark></p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</p><p>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</p><p>平台随着业务的发展从 All in One 环境就可以满足业务需求（以Java来说，可能只是一两个war包就解决了）。</p><p>发展到需要拆分多个应用，并且采用MVC的方式分离前后端，加快开发效率；在发展到服务越来越多，不得不将一些核心或共用的服务拆分出来，其实发展到此阶段，如果服务拆分的足够精细，并且独立运行，我觉得就可以将之理解为一个微服务了。</p><h2 id="常见命名规则以及适用场景" tabindex="-1"><a class="header-anchor" href="#常见命名规则以及适用场景"><span>常见命名规则以及适用场景</span></a></h2><ol><li>类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</li><li>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case），比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>。并且，测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</li><li>项目文件夹名称使用串式命名法（kebab-case），比如<code>dubbo-registry</code>。</li><li>包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 &quot;.&quot; 分隔符连接，并且各个单词必须为单数 <ul><li>正例： <code>org.apache.dubbo.common.threadlocal</code></li><li>反例： <code>org.apache_dubbo.Common.threadLocals</code></li></ul></li><li>抽象类命名使用 Abstract 开头。</li><li>异常类命名使用 Exception 结尾。</li><li>测试类命名以它要测试的类的名称开始，以 Test 结尾。</li></ol><h2 id="表设计规范" tabindex="-1"><a class="header-anchor" href="#表设计规范"><span>表设计规范</span></a></h2><h3 id="表与字段的规范" tabindex="-1"><a class="header-anchor" href="#表与字段的规范"><span>表与字段的规范</span></a></h3><ol><li><p>表名、字段名必须使用小写字母或数字并以下划线分隔 ， 禁止出现数字开头，禁止两个下划线中间只出现数字，名字要做到见名思意，不要超过32个字符。</p><p>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。</p><p>正例： <code>aliyun_admin </code>，<code>rdc_config</code> ， <code>level3_name</code></p><p>反例： <code>AliyunAdmin</code> ， <code>rdcConfig</code> ， <code>level_3_name</code></p></li><li><p>表达是与否概念的字段，必须使用 <code>is_xxx</code> 的方式命名，数据类型是 <code>unsigned tinyint</code>（ 1 表示是，0 表示否 ） 。</p><p>说明：任何字段如果为非负数，必须是 unsigned 。</p><p>正例：表达逻辑删除的字段名 is_deleted ，1 表示删除，0 表示未删除。</p></li><li><p>表必备三字段： <code>id</code> 主键, <code>create_time</code>创建时间 , <code>modified_time</code>更新时间 。</p></li><li><p>不同表之间存储相同数据的列名和列类型必须一致(关联列)</p></li><li><p>小数类型为 <code>decimal</code> ，禁止使用 <code>float</code> 和 <code>double</code> 。</p><p>说明： <code>float</code> 和 <code>double</code> 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>不得使用外键与级联，一切外键概念必须在应用层解决。</p></li><li><p>表和字段名要加注释</p></li><li><p>将字段很多的表分解成多个表</p><p>说明：将使用频率低的字段拿出来新建一个表，完成分表，从而提高效率</p></li><li><p>增加冗余字段</p><p>适当的不遵循范式的要求，对于经查查询的外表字段可以在本表中增加冗余字段。比如经常要查一个学生的系名，就可以在学生表加一个系名的字段</p></li><li><p>优先选择符合存储需要的最小、最简单的数据类型。</p><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。</p><p>①尽量使用数字型字段</p><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>②尽量使用位数较少的类型 ，比如能使用 TINYINT/SMALLINT 就不使用 int ，能使用无符号位就不适用有符号数据类型</p><p>③尽可能的使用 varchar/nvarchar 代替 char/nchar</p><p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。只有在存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li></ol><p>​</p><h2 id="索引规范" tabindex="-1"><a class="header-anchor" href="#索引规范"><span>索引规范</span></a></h2><ol><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li></ol><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的 。</p><ol start="2"><li><p>主键索引名为 <code>pk_字段名</code>；唯一索引名为 <code>uk_字段名</code> ； 普通索引名则为 <code>idx_字段名</code>。</p></li><li><p>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p></li><li><p>限制每张表的索引数量，建议每张表的索引数量不超过5个，并且针对复合索引，最常用的、区分度最高的(列中不同值数量/列的总行数)、字段长度小的放到最左侧</p></li><li><p>索引列定义为 not null</p></li></ol><p>说明：索引null列需要额外空间保存，需要占用更多地空间，运算和比较的时候会占用更多的空间</p><ol start="6"><li>值分布稀少的字段不适合建立索引，比如性别</li></ol>',57),o=[t];function c(d,r){return l(),a("div",null,o)}const h=e(p,[["render",c],["__file","standard.html.vue"]]),m=JSON.parse('{"path":"/system-design/standard.html","title":"架构及规范导航栏","lang":"zh-CN","frontmatter":{"description":"架构及规范导航栏 什么是Restful Restful是一种架构设计风格，提供了设计原则和约束条件，而不是架构，而满足这些约束条件和原则的应用程序或设计就是 Restful架构或服务。 主要的设计原则： 资源与URI 统一资源接口(HTTP方法如GET，PUT和POST) 资源的表述 资源的链接 状态的转移 总之，RESTful的核心就是后端将资源发布...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/system-design/standard.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"架构及规范导航栏"}],["meta",{"property":"og:description","content":"架构及规范导航栏 什么是Restful Restful是一种架构设计风格，提供了设计原则和约束条件，而不是架构，而满足这些约束条件和原则的应用程序或设计就是 Restful架构或服务。 主要的设计原则： 资源与URI 统一资源接口(HTTP方法如GET，PUT和POST) 资源的表述 资源的链接 状态的转移 总之，RESTful的核心就是后端将资源发布..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://images.xyzzs.top/image/image-20230206124146652.png_char"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-24T15:46:57.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:modified_time","content":"2024-04-24T15:46:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"架构及规范导航栏\\",\\"image\\":[\\"http://images.xyzzs.top/image/image-20230206124146652.png_char\\"],\\"dateModified\\":\\"2024-04-24T15:46:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"什么是Restful","slug":"什么是restful","link":"#什么是restful","children":[]},{"level":2,"title":"什么是SOAP","slug":"什么是soap","link":"#什么是soap","children":[]},{"level":2,"title":"RPC","slug":"rpc","link":"#rpc","children":[]},{"level":2,"title":"什么是SOA","slug":"什么是soa","link":"#什么是soa","children":[]},{"level":2,"title":"微服务","slug":"微服务","link":"#微服务","children":[]},{"level":2,"title":"为什么要使用微服务？","slug":"为什么要使用微服务","link":"#为什么要使用微服务","children":[]},{"level":2,"title":"常见命名规则以及适用场景","slug":"常见命名规则以及适用场景","link":"#常见命名规则以及适用场景","children":[]},{"level":2,"title":"表设计规范","slug":"表设计规范","link":"#表设计规范","children":[{"level":3,"title":"表与字段的规范","slug":"表与字段的规范","link":"#表与字段的规范","children":[]}]},{"level":2,"title":"索引规范","slug":"索引规范","link":"#索引规范","children":[]}],"git":{"createdTime":1713973617000,"updatedTime":1713973617000,"contributors":[{"name":"jossezs","email":"zzss5224@163.com","commits":1}]},"readingTime":{"minutes":10.77,"words":3232},"filePathRelative":"system-design/standard.md","localizedDate":"2024年4月24日","autoDesc":true}');export{h as comp,m as data};
