# MQ通用导航栏

| 特点              | RabbitMQ                                                     | ActiveMQ                                                | Kafka                                                        | RocketMQ                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 资料文档          | 资料数量多                                                   | 资料数量多                                              | 资料数量中等                                                 | 资料数量少，建议去官网上看，现成的demo倒是很方便             |
| 开发语言          | Erlang                                                       | Java                                                    | Scala                                                        | Java                                                         |
| 支持的协议        | AMQP                                                         | OpenWire、STOMP、REST、XMPP、AMQP                       | 自己定义的（基于TCP）                                        | 自己定义的                                                   |
| 消息存储          | 内存、磁盘。支持少量堆积                                     | 内存、磁盘、数据库。支持少量堆积。                      | 内存、磁盘、数据库。支持大量堆积                             | 磁盘。支持大量堆积。                                         |
| 消息事务          | 支持。客户端将信道设置为事务模式，只有当消息被RabbitMQ接收，事务才能提交成功，否则在捕获异常后进行回滚。使用事务会使得性能有所下降 | 支持                                                    | 支持                                                         | 支持                                                         |
| 负载均衡          | 负载均衡的支持不好                                           | 支持负载均衡。基于zookeeper实现负载均衡。               | 支持                                                         | 支持                                                         |
| 集群方式          | 支持简单集群，'复制'模式，对高级集群模式支持不好。           | 支持简单集群模式，比如'主-备'，对高级集群模式支持不好。 | 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。 | 常用 多对'Master-Slave' 模式，开源版本需手动切换Slave变成Master。 |
| 管理界面          | 好                                                           | 一般                                                    | 一般                                                         | 有管理后台, 但不是项目里自带, 需要自己启动一个单独的管理后台实例 |
| 可用性            | 高（主从）                                                   | 高（主从）                                              | 非常高（分布式）                                             | 非常高（分布式）                                             |
| 消息重复          | 支持at least once、at most once                              | 支持at least once                                       | 支持at least once、at most once                              | 支持at least once                                            |
| 单机吞吐量（TPS） | 万级（其次）                                                 | 万级（最差）                                            | 十万级（最大），Kafka按批次发送消息和消费消息。发送端将多个小消息合并，批量发向Broker，消费端每次取出一个批次的消息批量处理。 | 十万级（其次），RocketMQ接收端可以批量消费消息，可以配置每次消费的消息数，但是发送端不是批量发送。 |
| 顺序消息          | 不支持                                                       | 不支持                                                  | 支持                                                         | 支持                                                         |
| 消息回溯          | 不支持                                                       | 不支持                                                  | 支持指定分区offset位置的回溯                                 | 支持指定分区offset位置的回溯                                 |
| 消息重试          | 不支持，但是可以利用消息确认机制实现。                       | 不支持                                                  | 不支持，但是可以利用消息确认机制实现                         | 支持                                                         |



## 怎么防止消息不丢失

![image-20230201140325339](http://images.xyzzs.top/image/image-20230201140325339.png_char_char)

一次正常完整的发送消息可以分为三个阶段，分别是**生产消息、存储消息和消费消息**。我们从这三个阶段分别入手来看看如何确保消息不会丢失。

<mark>生产者发送消息不丢失</mark>

生产者发送消息至`Broker`，需要处理`Broker`的响应，不论是同步还是异步发送消息，同步和异步回调都需要做好`try-catch`，妥善的处理响应，如果`Broker`返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。

常见MQ实现方式

1. RabbitMQ

   - 消息发送+回调；

   - 手动事务：channel.txSelect()开启事务，channel.txCommit()提交事务，channel.txRollback()回滚事务。这种方式对channel会产生阻塞，造成吞吐量下降。
   - publisher Confirm，整个处理流程跟RocketMQ的事务消息基本一致

2. RocketMQ：

1. 1. 消息发送+回调
   2. 事务消息，流程如下图

![img](http://images.xyzzs.top/image/1668773364658-b3629a0e-a14b-4376-bafb-f3377a17285d.png_char)

<mark>MQ消息存盘不丢失</mark>

RocketMQ：同步刷盘和异步刷盘，异步刷盘效率更高，但是有可能丢消息；同步刷盘消息安全性更高，但是效率会降低。

RabbitMQ：将队列配置成持久化队列。新增的Quorum类型队列，会采用Raft协议来进行消息同步。

<mark>消费者消费消息不丢失</mark>

RocketMQ：使用默认的方式消费就行，不要采用异步方式

RabbitMQ：autoCommit -> 手动提交offset

kafka：[【1】](/java/message-queue/kafka.html#如何保证kafka不丢失消息)[【2】](https://blog.csdn.net/qq_19734597/article/details/119152030)

> 特殊情况下：可能还需要保证<mark>MQ主从消息同步不丢失</mark>
>
> RocketMQ
>
> 1.  普通集群，同步同步、异步同步。异步同步效率更高，但有风险丢失消息，同步同步	就不会丢消息。
> 2. 2Dledger集群：两阶段提交
>
> RabbitMQ
>
> 1. 普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的
> 2. 镜像集群：会在节点之间主动进行数据同步，这样数据安全性得到提高

## 如何保证消息消费的幂等性（重复消费）

其实就是要防止消费者重复消费消息的问题。

> **幂等（idempotent、idempotence）**是一个数学与计算机学概念，常见于抽象代数中。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,**无论多次执行，其结果都是一样的.**更复杂的操作幂等保证是利用唯一交易号(流水号)实现.

所有MQ产品并没有提供主动解决幂等性的机制，需要由消费者自行控制。

RocketMQ：给每个消息分配了个MessageID，这个MessageID可以作为消费者判断幂等性的依据，这种方式不太建议。

最好的方式是自己带一个有业务标识的ID，来进行幂等判断。（orderID，统一ID分配）

**分场景去考虑**，看是**强校验**还是**弱校验**

## 如何保证消息的顺序

全局有序和局部有序：MQ只需要保证局部有序，不需要保证全局有序

RocketMQ：**1生产者把一组有序的消息放在同一个队列，2而消费者一次消费整个队列当中的消息。**

![img](http://images.xyzzs.top/image/1668776845504-22ae4417-ac73-4f1e-93c2-2101cb77e163.png_char)

首先需要给这些消息一个相同的id，也可用已有的字段如订单号，一个订单的肯定是一个订单号的说，那简单了呀。

**一个topic下有多个队列**，为了保证发送有序，**RocketMQ**提供了**MessageQueueSelector**队列选择机制，他有三种实现：

我们可使用**Hash取模法**，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。RocketMQ的topic内的队列机制，可以保证存储满足FIFO，剩下的只需要消费者顺序消费即可。

**RocketMQ**仅保证顺序发送，顺序消费由消费者业务保证。

![](http://images.xyzzs.top/image/640_char_char)

RocketMQ中有完整的设计，但是在RabbitMQ和kafka当中，并没有完整的设计，需要自己去设计。



RabbitMQ：要保证目标exchange只对应一个队列，并且一个队列只对应一个消费者。

kafka：生产者通过定制partition分配规则，将消息分配到同一个partition。Topic只对应一个消费者。

## 如何保证消息的高效读写

零拷贝：kafka和RocketMQ都是通过零拷贝技术来优化文件读写。

mmap：文件大小不要超过1.5G~2G

transfile：没有文件大小限制

## 使用MQ如何保证分布式事务的最终一致性

保证事务的最终一致性，需要做到两点：

1. 生产者要保证100%的消息投递，事务消息机制
2. 消费者需要保证幂等性消费，唯一ID+业务自己实现

## 如何处理消息堆积

消息的堆积往往是因为**生产者的生产速度与消费者的消费速度不匹配**。有可能是因为消息消费失败反复重试造成的，也有可能就是消费者消费能力弱，渐渐地消息就积压了。

因此我们需要**先定位消费慢的原因**，如果是`bug`则处理 `bug` ，如果是因为本身消费能力较弱，我们可以优化下消费逻辑，比如之前是一条一条消息消费处理的，这次我们批量处理，比如数据库的插入，一条一条插和批量插效率是不一样的。

假如逻辑我们已经都优化了，但还是慢，那就得考虑水平扩容了，增加`Topic`的队列数和消费者数量，**注意队列数一定要增加**，不然新增加的消费者是没东西消费的。**一个Topic中，一个队列只会分配给一个消费者**。

当然你消费者内部是单线程还是多线程消费那看具体场景。不过要注意上面提高的消息丢失的问题，如果你是将接受到的消息写入**内存队列**之后，然后就返回响应给`Broker`，然后多线程向内存队列消费消息，假设此时消费者宕机了，内存队列里面还未消费的消息也就丢了。



事前

​	业务评测

事中

​	k8s扩缩容

事后

1. 提高消费并发

2. 批量消费

3. 跳过非重要消费

4. 优化每条消息消费

   

## 设计MQ

<!-- 从整体到细节，从业务场景到技术实现；以现有产品为基础 -->